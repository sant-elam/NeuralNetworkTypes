# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XL_DWoRQlPUPEsaefkfbcSurBpISDFDy
"""

import numpy as np
from sklearn.datasets import make_blobs

X, y = make_blobs(n_samples=500, centers=2)

import matplotlib.pyplot as plt
plt.scatter(X[:, 0], X[:, 1], c=y)
plt.show()

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y)

class SimplePerceptron():

    def __init__(self, learning_rate=0.005, epochs=100):
      self.epochs = epochs
      self.learning_rate = learning_rate

    # Training function
    def train(self, X, y ):
      num_samples = X.shape[0]
      num_features = X.shape[1]

      # initializing weights and bias
      self.weights = np.zeros(num_features)
      self.bias = 0

      for iter in range(self.epochs):
        # compute Summation function
        sum_values = np.dot(X, self.weights) + self.bias

        # compute activation function
        y_pedicted = self.ActivationFunction(sum_values)

        error = y - y_pedicted

        # compute gradient descent
        gradient = np.dot(X.T, error)

        # weight increment/decrement
        weight_increment = self.learning_rate * gradient

        # bias increment/decrement
        bias_increment = self.learning_rate * np.sum(error)

        # new weight
        self.weights += weight_increment

        # new bias
        self.bias += bias_increment

        return self.weights, self.bias


    def ActivationFunction(self, sum):

        sum_all =[]
        for item in sum:
          if item > 0:
            sum_all.append(1)
          else:
            sum_all.append(0)
        return np.array(sum_all)

    def predict(self, X):
      sum_val = np.dot(X, self.weights) + self.bias
      y_output = self.ActivationFunction(sum_val)
      return y_output

def GetAccuracy(y_test, y_pred):
  err_dif = abs(y_test - y_pred)
  err_avg = np.mean(err_dif)
  accuracy_test = 1.0 - err_avg
  accr = accuracy_test*100.0
  print(accr)
  return(accr)

def PlotGraph(X, y, weights, bias):

  fig = plt.figure(figsize=(8,6))
  plt.scatter(X[:,0], X[:,1], c=y)

  slope = - weights[0]/weights[1]
  intercept = - bias/weights[1]
  x_hyperplane = np.linspace(-10,10,10)
  y_hyperplane = slope * x_hyperplane + intercept
  plt.plot(x_hyperplane, y_hyperplane, '-')



  plt.show()

perceptron = SimplePerceptron(learning_rate =0.025, epochs = 50)
weight_, bias_ = perceptron.train(X_train, y_train)

print(weight_, bias_)

y_test_out = perceptron.predict(X_test)
print(y_test_out)

accr_test = GetAccuracy(y_test, y_test_out)

PlotGraph(X, y, weight_, bias_)